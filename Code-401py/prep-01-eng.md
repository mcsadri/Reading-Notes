# Prep: Engineering Readings

## Readings

[Act like you make $1000/hr](https://anthony-moore.medium.com/pretend-your-time-is-worth-1-000-hour-and-youll-become-100x-more-productive-6ab2302b8e8c)

- "The truth is, most people value their time at far, far less than it’s worth."
- "The most successful people I know are not busy. They’re focused.” - Jeff Goins
- "Busyness and exhaustion should be your enemy. If you’re chronically stressed and up late working, you’re doing something wrong. Do less. But do what you do with complete, hard focus. Then when you’re done be done, and go enjoy the rest of your day."
  - Oh, is that all it takes? <eyeroll.gif>
- "If you don’t treat yourself and your time with respect, you will become unhappy, resentful, and tired. Your body and mind long for mastery and freedom; you can’t have those things if your time is cheap and easily taken."
  - This is my native habitat.

[How to think like a programmer](https://medium.freecodecamp.org/how-to-think-like-a-programmer-lessons-in-problem-solving-d1d8bf1de7d2)

- Understand: Know exactly what is being asked. Most hard problems are hard because you don’t understand them (hence why this is the first step).
- Plan: Don’t dive right into solving without a plan (and somehow hope you can muddle your way through). Plan your solution!
  - “Given input X, what are the steps necessary to return output Y?”
- Divide: break it into sub-problems. These sub-problems are much easier to solve. Then connect them together for the larger solution.
- Stuck? The difference is the best programmers/problem-solvers are more curious about bugs/errors than irritated.
  - Debug
  - Reassess
  - Research
- Practice: If you want to be a good problem-solver, solve a lot of problems!
[Solving Problems](https://simpleprogrammer.com/solving-problems-breaking-it-down/)
- The most common mistake I see when conducting interviews or watching someone try to solve a programming problem is they try to start writing code as soon as possible.
- You really want to make sure you take enough time to understand the problem completely before attempting to solve it.
- Another big mistake is trying to over solve the solution on the first iteration.  Keep it simple, don’t try to get fancy.
- A simple set of steps (As much as 70% of our time should be spent in steps 1-3.):
  - Read the problem completely twice.
  - Solve the problem manually with 3 sets of sample data.
    - don’t forget to look for corner cases and edge cases and do any examples for those kind of cases you can think of
    - Optimize the manual steps.
      - It is much easier to rearrange and reconstruct and idea or algorithm in your head than it is in code.
    - Write the manual steps as comments or pseudo-code.
      - capture all the steps we created and now either put them into our editor as comments or write them as psuedo-code that we can translate to real code.
    - Replace the comments or pseudo-code with real code.
      - If you struggle here, there are usually two possible reasons:
        - You didn’t break down the problem into small enough steps.
          - Try going back to the second step and being as meticulous as possible.
        - You don’t know your programming language well enough to do the conversion
          - Any language you expect to be able to solve algorithm type problems in, you should know how to do the following things:
            - Create a list
            - Sort a list or array
            - Create a map or dictionary
            - Loop through a list, or dictionary
            - Parse strings
            - Convert from string to int, int to string, etc
    - Optimize the real code.
      - Can anything be simplified?
      - Make sure variables & methods have meaningful names

[The 5 Whys](https://www.mindtools.com/pages/article/newTMC_5W.htm)

- The 5 Whys uses "counter-measures," rather than "solutions." A counter-measure is an action or set of actions that seeks to prevent the problem from arising again, while a solution may just seek to deal with the symptom. As such, counter-measures are more robust, and will more likely prevent the problem from recurring.
- You can use 5 Whys for troubleshooting, quality improvement, and problem solving, but it is most effective when used to resolve simple or moderately difficult problems.
- How to Use the 5 Whys
  - Assemble a team
  - define the problem
  - Ask the first "why?"
  - Ask "why?" four more times
    - Try to move quickly from one question to the next, so that you have the full picture before you jump to any conclusions.
  - Know when to stop
  - Address the root cause(s)
  - Monitor your measures

[The Super Mario Effect](https://www.youtube.com/watch?v=9vJRopau0g0)

- Reframe the challenge

## Discussion Questions

- What’s the one thing I bring to this career (and a potential employer) that nobody else can?
- What are 3 things I’ll start doing to “un-stick” myself whenever I get stuck on tough piece of code, logic, or feature?
